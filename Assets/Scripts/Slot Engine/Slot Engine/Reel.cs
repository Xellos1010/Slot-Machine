//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Reel.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
public class Reel : MonoBehaviour
{
    public MatrixTypes matrix;
    public Slot[] slSlots;
    public delegate void SpinDelegate();
    public delegate void SpinDelegateSwitch(States State);
    public event SpinDelegate ActivateSpinState;
    public event SpinDelegateSwitch SpinStateSwitched;

    private int iSlotEndingNumber;
    public int iExtraSlots; //Padding for smooth spins
    private Symbols[] EndReelConfiguration;

    [Range(0, 500)]
    public float fSpinSpeed = 125;

	public void SpinReel()
    {
        fSpinSpeed = 400;
        ActivateSpinState();
	}

    public void StopReel()
    {
        fSpinSpeed = 450;
    }

    public void GenerateSlots(int iSlotCount, Transform tParent)
    {
        GenerateStartingSlotY(iSlotCount);
        slSlots = new Slot[iSlotCount];
        for (int i = 0; i < iSlotCount; i++)
        {
            slSlots[i] = CreateSlot(i);
            slSlots[i].transform.name = "Slot_" + i;
            //Set transform Before Setting Parent
            slSlots[i].transform.parent = tParent;
            slSlots[i].transform.position = GenerateLocalPosition(i);
            //slSlots[i].transform.localScale = GenerateLocalScale();
            slSlots[i].SetRandomSymbol();
            slSlots[i].rReelParentObject = this;
            slSlots[i].iPositonInReel = i;
            slSlots[i].SetEventCalls(this);
        }
    }

    public void SetSlotEndConfiguration()
    {
        Debug.Log("Setting Ending Slot Configuration for " + transform.name);
        EndReelConfiguration = GenerateEndSymbols();
        iSlotEndingNumber = slSlots.Length;
    }

    public void SetSlotEndConfiguration(Symbols[] Input)
    {
        //Debug.Log("Setting Ending Slot Configuration for " + transform.name);
        EndReelConfiguration = Input; 
        iSlotEndingNumber = slSlots.Length;
    }

    public void SetSlotEndConfiguration(Slot sSlot)
    {
        if (iSlotEndingNumber >= 0)
        {
            sSlot.SwitchSymbol(EndReelConfiguration[iSlotEndingNumber]);
        }
        else
        {
            Debug.Log(transform.name + " had trouble setting slot " + sSlot.transform.name + " the iSlotEndingNumber is " + iSlotEndingNumber);
        }
    }

    Slot CreateSlot(int iSlotNumber)
    {
        GameObject ReturnValue = Instantiate(Resources.Load("Prefabs/Slot")) as GameObject;//new GameObject("Slot_" + iSlotNumber, SlotComponents).GetComponent<Slot>();
        //ReturnValue.Ran
        Debug.Log("Creating Slot from prefab");
        return ReturnValue.GetComponent<Slot>();
    }

    public void SyncronizePositionAllSlots()
    {
        int iLoopPositionSetCount = 0;
        //Do not start at the last slot. It will always be the correct position
        for (int i = slSlots.Length - 1;i >= 0; i--)
        {
            if (slSlots[i].bLoopPositionSet == false)
                break;
            else
            {
                ++iLoopPositionSetCount;
                continue;
            }
        }
        if (iLoopPositionSetCount == slSlots.Length)
        {
            //Debug.Log("SyncronizePositionAllSlots()");
            for (int i = slSlots.Length - 2; i >= 0; i--)
            {
                //slSlots[i].SyncronizePositionToNextSlot();
            }
        }
    }

    public Vector3 SyncronizePositionNextSlot(Slot sSlotSyncronize)
    {
        int iComparingSlot = sSlotSyncronize.iPositonInReel + 1;
        if (iComparingSlot >= slSlots.Length)
            iComparingSlot = 1;
        //Debug.Log("SyncronizePosition(" + sSlotSyncronize.name + ") iComparingSlot = " + iComparingSlot + ". Returning " + slSlots[iComparingSlot].transform.localPosition);
        foreach (Slot slot in slSlots)
        {
            //Debug.Log("Comparing " + slot.transform.name + " to " + sSlotSyncronize.name + " slot.iPositionInReel = " + slot.iPositonInReel + " iComparingSlot =" + iComparingSlot);
            if (slot.iPositonInReel == iComparingSlot)
            {
                //Debug.Log(transform.name + " is SyncronizePositionNextSlot(" + sSlotSyncronize.transform.name + ") Next slot is " + iComparingSlot + " slot.transform.name = " + slot.transform.name + " slot.transform.localPosition = " + slot.transform.localPosition);
                return slot.transform.localPosition;
            }
        }
        //Debug.Log("Returning 0 for " + transform.name + " iComparingSlot = " + iComparingSlot);
        return Vector3.zero;
    }

    void GenerateStartingSlotY(int iSlotCount)
    {
        SlotEngine._instance.fStartingSpotSlot = SlotEngine._instance.v2ReelTopLeft.y + (SlotEngine._instance.slotPaddingY * (SlotEngine._instance.iExtraSlotsPerReel-1)); 
    }

    //**Need to have slots generate their position
    Vector3 GenerateLocalPosition(int iSlotNumber)
    {
        //Change later to enter customizes reel starting height (Matrix 3x4x5x4x3)
        //Need To Determine How many Slots are in the Reel and calculate the iExtraSlotsPerReel (-1 to include the end slot not being active)
        //of the reel into the starting Y Position

        float yAxis = SlotEngine._instance.fStartingSpotSlot - (SlotEngine._instance.slotPaddingY * iSlotNumber);
        //if(
        //yAxis = SlotEngine._instance.v2ReelTopLeft.y  SlotEngine._instance.iExtraSlotsPerReel
        return new Vector3(0, yAxis, 0);
    }
    
    public float GenerateEndPositionAndSymbol(Slot slSlot)
    {
        //Debug.Log(transform.name + " Has iSlotEndingNumber at " + iSlotEndingNumber + " While Generating Symbol and positon for slot " + slSlot.transform.name);
        if (iSlotEndingNumber >= 0)
        {
            slSlot.iEndPositionInReel = iSlotEndingNumber;
            //Needs to be decreased here due to the count of the array not including 0 of an index value
            if(iSlotEndingNumber - 1 >= 0)
                iSlotEndingNumber -= 1;
            try
            {
                slSlot.SwitchSymbol(EndReelConfiguration[iSlotEndingNumber]);
            }
            catch
            {
                Debug.Log("There is an issue with the iSlotEndingNumber " + iSlotEndingNumber);
            }
            return GenerateLocalPosition(iSlotEndingNumber).y;
        }
        else
        {
            Debug.Log(transform.name + " Has iSlotEndingNumber at " + iSlotEndingNumber + " While Generating Symbol and positon for slot " + slSlot.transform.name);
        }
        return 0;
    }

    internal void UpdateSlotPositions()
    {
        for (int i = 0; i < slSlots.Length; i++)
        {
            slSlots[i].transform.position = GenerateLocalPosition(i);
        }
    }
        public Symbols[] GenerateEndSymbols()
    {
        Symbols[] temp = new Symbols[slSlots.Length];
        for (int i = 0; i < temp.Length; i++)
        {
            temp[i] = (Symbols)Random.Range(0, (int)Symbols.End - 1);
        }
        return temp;
    }

    public void PlayAnimationSpecificSlot(int iSlotNumber)
    {
        slSlots[iSlotNumber].PlayAnimation();
    }

    internal void ClearReelSlots()
    {
        for (int i = transform.childCount - 1; i >= 0; i--)
            DestroyImmediate(transform.GetChild(i).gameObject);
    }

    /*void Update()
    {
        if (StateManager.enCurrentState == States.BaseGameSpinLoop)
        {
            for (int i = slSlots.Length-1; i >= 0; i--)
            {
                Debug.Log("slSlots["+i+"]");
                slSlots[i].CheckPosition();
            }
        }
    }*/

}

#if UNITY_EDITOR
[CustomEditor(typeof(Reel))]
class ReelEditor : Editor
{
    Reel myTarget;
    SerializedProperty iExtraSlots;
    public void OnEnable()
    {
        myTarget = (Reel)target;
        iExtraSlots = serializedObject.FindProperty("iExtraSlots");
    }

    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        if (GUILayout.Button("Generate Slots"))
        {
            myTarget.ClearReelSlots();
            Vector2 v2Matrixtemp = (Vector2)ReturnMatrixtype(myTarget.matrix);
            int extraslots = 0;
            try
            {
                extraslots = SlotEngine._instance.iExtraSlotsPerReel;
            }
            catch
            {
                extraslots = iExtraSlots.intValue;
            }
            myTarget.GenerateSlots((int)v2Matrixtemp.x + extraslots, myTarget.transform);
        }
        if (GUILayout.Button("Spin Reel Test"))
        {
            myTarget.SpinReel();
        }
    }

    public object ReturnMatrixtype(MatrixTypes mMatrix)
    {
        object ReturnValue = null;

        switch (mMatrix)
        {
            case MatrixTypes.m3x5:
                ReturnValue = new Vector2(3, 5);
                break;
            case MatrixTypes.m3x6:
                ReturnValue = new Vector2(3, 6);
                break;
            case MatrixTypes.m4x5:
                ReturnValue = new Vector2(4, 5);
                break;
            case MatrixTypes.m4x6:
                ReturnValue = new Vector2(4, 6);
                break;
            default:
                Debug.Log("Matrix is not able to set Vector2 to Define. Sending Matrix as an int[]");
                if (mMatrix == MatrixTypes.m3x4x5x4x3)
                    ReturnValue = new int[5] { 3, 4, 5, 4, 3 };
                break;
        }

        return ReturnValue;
    }
}
#endif