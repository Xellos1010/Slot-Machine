//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Slot.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;

public class Slot :MonoBehaviour
{
    Slot(Symbols Symbol)
    {
        enSymbol = Symbol;
    }

    public Symbols enSymbol = Symbols.None;
    public States enSlotState = States.None; 
    public Reel rReelParentObject;
    public int iPositonInReel = 0;
    public int iEndPositionInReel = 0;

    public Vector3[] v3CurrentTweenpath;
    private float fEndingPos;
    public Rect[] rects;

    private TPSpriteAnimationEx _Sprite;
    public TPSpriteAnimationEx Sprite
    {
        get
        {
            if (_Sprite == null)
                _Sprite = GetComponent<TPSpriteAnimationEx>();
            return _Sprite;
        }
        set
        {
            _Sprite = value;
        }
    }

    public bool bLoopPositionSet = false;

    //Unity Default Functions

    //*************

    void StateSwitch(States state)
    {
        //Debug.log("State switched to " + state.ToString());
        if (state == States.BaseGameSpinLoop || state == States.BonusGameSpinLoop)
        {
            enSlotState = state;
        }
        else if (state == States.BaseGameSpinEnd || state == States.BonusGameSpinEnd)
        {
            enSlotState = States.BaseGameSpinEnd;
        }
    }

    public void PlayAnimation()
    {
        Sprite.frameRate = 24;
        Sprite.Play();

    }

    public void StopAnimation()
    {
        Sprite.frameRate = 24;
        Sprite.Stop();
    }

    public void StartSpin()
    {
        StopAnimation();
        enSlotState = States.BaseGameSpinStart;
        Hashtable hSettings = iTweenParametersSpin(iTween.EaseType.easeInBack);
        iTween.MoveTo(this.gameObject,hSettings);
    }

    Hashtable iTweenParametersSpin(iTween.EaseType EaseType)
    {
        Hashtable ReturnValue = new Hashtable();
        ReturnValue.Add("name", transform.parent.name + " " + transform.name);
        ReturnValue.Add("speed",SlotEngine._instance.fStartStopSpeed);
        //ReturnValue.Add("easetype", EaseType);
        ReturnValue.Add("easetype", EaseType);
        //ReturnValue.Add("islocal", true);
        ReturnValue.Add("position",GeneratePosition());
        v3CurrentTweenpath = new Vector3[2];
        v3CurrentTweenpath[0] = transform.position;
        v3CurrentTweenpath[1] = GeneratePosition();
        if (StateManager.enCurrentState == States.BaseGameSpinStart)
        {
            ReturnValue.Add("oncompletetarget", this.gameObject);
            ReturnValue.Add("oncomplete", "SetSpinToLoop");
        }
        else if (StateManager.enCurrentState == States.BaseGameSpinLoop)
        {
            ReturnValue.Add("onupdatetarget", this.gameObject);
            //ReturnValue.Add("onupdateparams", transform);
            ReturnValue.Add("onupdate", "CheckStatePosition");
            ReturnValue.Add("oncompletetarget", this.gameObject);
            //ReturnValue.Add("oncomplete", "MoveToTop");
            ReturnValue.Add("oncomplete", "IncrementPositionInReel");

        }
        else if (StateManager.enCurrentState == States.BaseGameSpinEnd)
        {
            ReturnValue.Add("oncompletetarget", this.gameObject);
            ReturnValue.Add("oncomplete", "PlayAnimation");
        }
        return ReturnValue;
    }

    Vector3 GeneratePosition()
    {
        //Debug.Log("Generating Position in " + transform.name + " with a state of " + StateManager.enCurrentState.ToString());
        if (enSlotState == States.BaseGameSpinStart || enSlotState == States.BonusGameSpinStart)
            return new Vector3(transform.position.x, (transform.localPosition.y - (SlotEngine._instance.slotPaddingY)), 0);
        else if (enSlotState == States.BaseGameSpinLoop || enSlotState == States.BonusGameSpinLoop)
        {
            //Debug.Log("Generateing Loop Position of " + GenerateLoopPosition() +  " for " + transform.name);
            return GenerateLoopPositionStart();
        }
        else if (enSlotState == States.BaseGameSpinEnd || enSlotState == States.BonusGameSpinEnd)
            return new Vector3(transform.position.x, fEndingPos, 0);
        else
        {
           //Debug.Log(transform.name + " in reel " + transform.parent.name + " Generated a Vector3.Zero for a Position. Possible StateManager Issue current state is " + StateManager.enCurrentState.ToString());
            return Vector3.zero;
        }
    }

    Vector3 GenerateSlotStartingPosition()
    {
        float yAxisValue = 0;
        yAxisValue = SlotEngine._instance.fStartingSpotSlot - (SyncronizePositionToNextSlot(SlotEngine._instance.fStartingSpotSlot, ReturnNextSlot().transform.position));
        //Debug.Log("GenerateCurrentStartPosition() for " + transform.name + " is returning a yAxisValue of " + yAxisValue);
        return new Vector3(transform.localPosition.x, yAxisValue, transform.localPosition.z);
    }

    Vector3 GenerateCurrentStartPathPositionTween()
    {
        float yAxisValue = 0;
        yAxisValue = SlotEngine._instance.fStartingSpotSlot - (SlotEngine._instance.slotPaddingY * iPositonInReel);
        //Debug.Log("GenerateCurrentStartPosition() for " + transform.name + " is returning a yAxisValue of " + yAxisValue);
        return new Vector3(transform.localPosition.x, yAxisValue, transform.localPosition.z);
    }

    Vector3 GenerateLoopPositionStart()
    {
        float yAxisValue = 0;
        yAxisValue = SlotEngine._instance.fStartingSpotSlot - (SlotEngine._instance.slotPaddingY * iPositonInReel);
        //Debug.Log("GenerateLoopPosition() for " + transform.name + " in " + transform.parent.name + " is returning a yAxisValue of " + yAxisValue);
        return new Vector3(transform.position.x,yAxisValue,transform.position.z);
    }

    Vector3 GenerateEndPosition()
    {
        return new Vector3(transform.position.x, (SlotEngine._instance.fStartingSpotSlot - (SlotEngine._instance.slotPaddingY * transform.parent.childCount)), 0);
    }

    Vector3 GenerateNextTweenPosition()
    {
        float yAxisValue = 0;
        yAxisValue = SlotEngine._instance.fStartingSpotSlot - (SlotEngine._instance.slotPaddingY * (iPositonInReel+1));
        //Debug.Log("GenerateCurrentStartPosition() for " + transform.name + " is returning a yAxisValue of " + yAxisValue);
        return new Vector3(transform.localPosition.x, yAxisValue, transform.localPosition.z);
    }

    Slot ReturnNextSlot()
    {
        int iPositionToFind = iPositonInReel + 1;
        if (iPositionToFind > rReelParentObject.slSlots.Length)
            iPositionToFind = 1;
        foreach (Slot slot in rReelParentObject.slSlots)
        {
            //Debug.Log("Checking Slot " + slot.transform.name + " with a position in reels of " + slot.iPositonInReel);
            if (slot.iPositonInReel == iPositionToFind)
            {
                return slot;
            }
            else if (slot.iPositonInReel == iPositonInReel && transform != slot.transform)
                return slot;
        }
        Debug.Log("Error Returning Next Slot for " + transform.name + " Current Position in reel = " + iPositonInReel + " trying to find position " + iPositionToFind);
        return null;
    }

    private void SetSpinLoopState()
    {
        //Debug.Log("Setting Spin State to loop for " + transform.name);
        if( enSlotState != States.BaseGameSpinLoop && enSlotState != States.BonusGameSpinLoop)
            if(StateManager.enCurrentState == States.BaseGameSpinStart || StateManager.enCurrentState == States.BaseGameSpinLoop)
                enSlotState = States.BaseGameSpinLoop;
            else if(StateManager.enCurrentState == States.BonusGameSpinStart || StateManager.enCurrentState == States.BonusGameSpinLoop)
                enSlotState = States.BonusGameSpinLoop;
    }

    public void SetEventCalls(Reel rParent)
    {
        rParent.ActivateSpinState += StartSpin;
        rParent.SpinStateSwitched += StateSwitch;
    }

    //This will Set proper spin state and Increment Position in Reels
    private void SetSpinToLoop()
    {
        bLoopEnabled = true;
        ResetTimeLeftFPS();
        SetSpinLoopState();
        //IncrementPositionInReel();
    }

    private void SetSpinToEnd()
    {
        //bLoopEnabled = false; 
        fEndingPos = rReelParentObject.GenerateEndPositionAndSymbol(this);
        enSlotState = States.BaseGameSpinEnd;
        //The reel parent by this point should have pulled the generated symbol matrix from the slot engine and sets the reel symbols based on who reaches the top first.
        //rReelParentObject.fSpinSpeed = 95;
    }

    private void SetTweenOnPathEnd()
    {
        bLoopEnabled = false;
        rReelParentObject.fSpinSpeed = 75;
        /*if (transform.GetComponent("iTween"))
        {
            Destroy(transform.GetComponent<iTween>());
        }*/
        //Need to change iTween to make ending transition smoother
        Hashtable hSettings = iTweenParametersSpin(iTween.EaseType.easeOutBack);
        iTween.MoveTo(this.gameObject, hSettings);
        iEndPositionInReel = 0;
        //Need to have GenerateEndEase() Generate an update base on the reel speed to cushion the slot to spin pass the ending pos slot then ease back.
    }

    private void SetTweenOnPathLoop()
    {
        //Debug.Log(transform.name + " SetTweenOnPathLoop()");
        v3CurrentTweenpath = new Vector3[2];
        //Slot Reel needs to  be incremented before this point to accuratly check the "next" slot
        v3CurrentTweenpath[0] = GenerateCurrentStartPathPositionTween();
        v3CurrentTweenpath[1] = GenerateNextTweenPosition();

        /*float fDistance = rReelParentObject.fSpinSpeed * Time.deltaTime;

        float correctY = transform.position.y - fDistance;
        float correctPercentage = correctY / (v3CurrentTweenpath[0].y - v3CurrentTweenpath[1].y);
        //float fDistance = rReelParentObject.fSpinSpeed * transform.GetComponent<iTween>().
        *///iTween.PutOnPath(this.gameObject, v3CurrentTweenpath, correctPercentage);
    }

    private void SetTweenOnPath(iTween tTween)
    {
        v3CurrentTweenpath = new Vector3[2];
        v3CurrentTweenpath[0] = tTween.transform.position;
        v3CurrentTweenpath[1] = GeneratePosition();
        float fDistance = rReelParentObject.fSpinSpeed * Time.deltaTime;
        iTween.PutOnPath(this.gameObject, v3CurrentTweenpath, 0);
    }

    private void SetTweenOnPath(Vector3 v3StartingPos)
    {
        v3CurrentTweenpath = new Vector3[2];
        v3CurrentTweenpath[0] = v3StartingPos;
        v3CurrentTweenpath[1] = GeneratePosition();
        float fDistance = rReelParentObject.fSpinSpeed * Time.deltaTime;
        iTween.PutOnPath(this.gameObject, v3CurrentTweenpath, 0);
    }

    private void SetTweenOnPath(float fPercentage)
    {
        iTween.PutOnPath(this.gameObject, v3CurrentTweenpath, fPercentage);
    }

    private void SetTweenOnPath(Vector3 v3StartingPos, Vector3 v3EndingPos)
    {
        v3CurrentTweenpath = new Vector3[2];
        v3CurrentTweenpath[0] = v3StartingPos;
        v3CurrentTweenpath[1] = v3EndingPos;
        float fDistance = rReelParentObject.fSpinSpeed * Time.deltaTime;
        iTween.PutOnPath(this.gameObject, v3CurrentTweenpath, 0);
    }

    void IncrementPositionInReel()
    {
        //Debug.Log(transform.name + " is Incrementing Position In Reel " + transform.parent.name + " from " + iPositonInReel + " to" + (iPositonInReel + 1));
        //GetSymbol to set self to and new reel slot position from ReelParent.
        //The reel parent by this point should have pulled the generated symbol matrix from the slot engine and sets the reel symbols based on who reaches the top first.
        DestroyTween();
        if (iPositonInReel + 1 >= rReelParentObject.slSlots.Length && (enSlotState != States.BaseGameSpinEnd || enSlotState != States.BonusGameSpinEnd))
        {
            //Debug.Log("transform.parent.childCount = " + transform.parent.childCount + " iPositionInReel = " + iPositonInReel + " via IncrementPositionInReel()");
            MoveToTop();
        }
        else
        {
            iPositonInReel += 1;
        }
        if ((enSlotState == States.BaseGameSpinEnd || enSlotState == States.BonusGameSpinEnd) && iPositonInReel == iEndPositionInReel - 1)
        {
            SetTweenOnPathEnd();
            //SetTweenOnPathLoop();
        }
        else
            SetTweenOnPathLoop();
    }

    public float SyncronizePositionToNextSlot()
    {
        foreach (Slot slot in rReelParentObject.slSlots)
        {
            if (slot.iPositonInReel == iPositonInReel + 1)
            {
                return SyncronizePositionToNextSlot(slot.transform.position);
            }
        }
        Debug.Log("Could not Sync with Next slot position " + transform.name + " Position in reel = " + iPositonInReel + " Further troubleshooting required");
        return 0;
    }

    public float SyncronizePositionToNextSlot(Vector3 NextSlot)
    {
        float currentY = transform.position.y;
        float currentPercentageOnPath = currentY / (v3CurrentTweenpath[1].y - v3CurrentTweenpath[0].y);

        float correctY = NextSlot.y + SlotEngine._instance.slotPaddingY;
        //float correctPercentage = correctY / (v3CurrentTweenpath[1].y - v3CurrentTweenpath[0].y);
        return correctY;
    }

    public float SyncronizePositionToNextSlot(float fFutureY, Vector3 NextSlot)
    {
        float currentY = fFutureY;
        float currentPercentageOnPath = currentY / (v3CurrentTweenpath[1].y - v3CurrentTweenpath[0].y);

        float correctY = NextSlot.y + SlotEngine._instance.slotPaddingY;
        float differentY = currentY - correctY;
        return differentY;
    }

    public void CheckStatePosition()
    {
        if (transform.position.y <= GenerateEndPosition().y)
        {
            MoveToTop();
        }
        Debug.Log(transform.name + " is CheckingStatePosition(). transform.parent.childCount = " + transform.parent.childCount);

        iTween Tween = transform.GetComponent<iTween>();
        if (enSlotState == States.BaseGameSpinLoop || enSlotState == States.BonusGameSpinLoop)
        {
            Tween.easeType = iTween.EaseType.linear;
        }
        else if (enSlotState == States.BaseGameSpinEnd || enSlotState == States.BonusGameSpinEnd)
        {
            //SetPositionOfTweenOnReel and Set Symbol based on input
            //SetTweenOnpath(Tween);
            //SetSymbol();
        }
    }

    void DestroyTween()
    {
        Destroy(transform.GetComponent<iTween>());
    }

    void MoveToTop()
    {
        //Need to determine if state is in loop or spin ending. if it is spin ending send transform parent a message to give what symbol to set self to
        iPositonInReel = 0;
        transform.localPosition = GenerateSlotStartingPosition();
        SetTweenOnPathLoop();
        SyncronizePositionToNextSlot(rReelParentObject.SyncronizePositionNextSlot(this));
        DestroyTween();
        //Debug.log("rReelParentObject.SyncronizePositionNextSlot(this) = " + rReelParentObject.SyncronizePositionNextSlot(this));
        //Debug.Log(transform.name + " on reel " + transform.parent.name + " localPositon has been set " + SlotEngine._instance.fStartingSpotSlot + " via MoveToTop()");
        /*if (enSlotState == States.BaseGameSpinLoop || enSlotState == States.BonusGameSpinLoop || enSlotState == States.BaseGameSpinStart || enSlotState == States.BonusGameSpinStart)
        {
            Hashtable Settings = iTweenParametersSpin(iTween.EaseType.linear);
            iTween.MoveTo(this.gameObject, Settings);
        }*/
        if(StateManager.enCurrentState == States.BaseGameSpinEnd || StateManager.enCurrentState == States.BonusGameSpinEnd)
        {
            //Debug.Log(transform.name + " on reel " + transform.parent.name + " is executing SetSpinToEnd()");
            SetSpinToEnd();
            if (iEndPositionInReel <= 1)
            {
                SetTweenOnPathEnd();
                iPositonInReel = 0;
            }
        }
    }
           
    /// <summary>
    /// Sets the graphic for the slot to toSymbol
    /// </summary>
    /// <param name="toSymbol">Symbol to set graphic to</param>
    public void SetSymbolGraphicTo(Symbols toSymbol)
    {
        enSymbol = toSymbol;
        ResetSymbolTextureTo();
    }

    public void SwitchSymbol(Symbols Symbol)
    {
        enSymbol = Symbol;
        ResetSymbolTextureTo();
    }

    private void ResetSymbolTextureTo()
    {
        Sprite.sprite.frames = new System.Collections.Generic.List<TPFameInfo>(Sprite.sprite.frames.Count);
        //Sets the frames to the Symbol Chosen from the skin folder
        for(int i = 0; i < Sprite.sprite.frames.Count; i++)
            Sprite.sprite.frames[i] = new TPFameInfo(ReturnSymbolFrameInfo(i), 
                enSymbol.ToString() + "_0" + String.Format("{0:0#}",i) + ".png");
        Sprite.sprite.showFrame(0);
        //Debug.Log("Showing Frame 0");
    }

    internal string GenerateSymbolTextureName(Symbols symbol, int frameNumber)
    {
        return symbol.ToString() + "_0" + String.Format("{0:0#}", frameNumber) + ".png";
    }

    private string ReturnSymbolFrameInfo(int iFrameNumber)
    {
        return "Skins/" + SlotEngine._instance.eSkin.ToString() + "/"
            + SlotEngine._instance.CurrentMode.ToString()
            + "/Symbols/"
            + enSymbol.ToString();
    }

    private string GenerateAdditionalString(int iPlace)
    {
        if (iPlace < 10)
            return "0" + iPlace.ToString();
        else
            return iPlace.ToString();
    }

    private void SetSpinSymbol(int iFrame)
    {
        Sprite.currentFrame = iFrame;
    }

    public void SetGraphicToRandomSymbol()
    {
        SetSymbolGraphicTo(GenerateRandomSymbol());
    }

    /// <summary>
    /// Generates a random symbol and returns
    /// </summary>
    /// <returns></returns>
    Symbols GenerateRandomSymbol()
    {
        return (Symbols)UnityEngine.Random.Range(0, (int)Symbols.End - 1);
    }

    Vector3 GenerateLoopPositionUpdate()
    {
        float currentY = transform.position.y;
        float currentPathPercentage = transform.position.y / v3CurrentTweenpath[1].y;
        //Debug.Log("Frames Per Second = " + framesPerSecond);
        float DistanceToTravel = 0;
        if (framesPerSecond > 0)
            DistanceToTravel = ((rReelParentObject.fSpinSpeed / fSpinTime)/30);//Need to replace to point fps to systems FPS Cap
        else
            DistanceToTravel = ((rReelParentObject.fSpinSpeed / fSpinTime) / framesPerSecond);
        float nextY = currentY - DistanceToTravel;
        //Debug.Log("DistanceToTravel = " + DistanceToTravel + " Next Y = " + nextY);
        Vector3 temp = GenerateLoopPositionStart();
        //return new Vector3(temp.x, transform.position.y - fLoopSpeed, temp.z); 
        //need to update coe to have reels spin behind background Texture.
        /*if(iPositonInReel > SlotEngine._instance.iExtraSlotsPerReel && iPositonInReel <= (rReelParentObject.slSlots.Length - SlotEngine._instance.iExtraSlotsPerReel))
            return new Vector3(temp.x, nextY, temp.z-10); 
        else*/
            return new Vector3(temp.x, nextY, temp.z); 
    }

    Vector3 GenerateNextSymbolLocationWithPadding()
    {
        return new Vector3(transform.localPosition.x, rReelParentObject.SyncronizePositionNextSlot(this).y + SlotEngine._instance.slotPaddingY, transform.localPosition.z);
    }

    public bool bLoopEnabled = false;
    [Range(0,1)]
    public float fSpinTime = .49025f;

    //Keeps track of the FPS so the reels spinning are affected by the games FPS
    float updateInterval = 0.5f;
 
    private float accum = 0.0f; // FPS accumulated over the interval
    private float framesPerSecond = 0;
    private int frames = 0; // Frames drawn over the interval
    private float timeleft = .5f; // Left time for current interval

    void ResetTimeLeftFPS()
    {
        timeleft = updateInterval;
    }

    private void ResetAllVars()
    {
        v3CurrentTweenpath = new Vector3[2];
        fEndingPos = 0;

    }

    public void CheckPosition()
    {
        if (bLoopEnabled)
        {
            if (fSpinTime == 0)
                fSpinTime = .49025f;
            //GenerateLoopPositionUpdate();
            //fLoopSpeed = .49025f;
            if (transform.position.y <= GenerateLoopPositionStart().y)
            {
                IncrementPositionInReel();
            }
                Hashtable hSettings = new Hashtable();
                hSettings.Add("time", fSpinTime);
                hSettings.Add("position", GenerateLoopPositionUpdate());
                iTween.MoveUpdate(this.gameObject, hSettings);
                //bLoopEnabled = false;
        }
    }

    void Update()
    {
        /*if (Input.GetKeyDown(KeyCode.Space) || Input.touchCount > 0)
        {
            PlayAnimation();
        }*/
        timeleft -= Time.deltaTime;
        accum += Time.timeScale / Time.deltaTime;
        ++frames;

        // Interval ended - update GUI text and start new interval
        if (timeleft <= 0.0)
        {
            framesPerSecond = accum / frames;
            ResetTimeLeftFPS();
            accum = 0.0f;
            frames = 0;
        }
        
        if (bLoopEnabled)
        {
            if (fSpinTime == 0)
                fSpinTime = .49025f;
            //GenerateLoopPositionUpdate();
                //fLoopSpeed = .49025f;
            if (transform.position.y <= v3CurrentTweenpath[1].y)
            {
                IncrementPositionInReel();
            }
            Hashtable hSettings = new Hashtable();
            //hSettings.Add("time", fLoopSpeed);
            hSettings.Add("position", GenerateLoopPositionUpdate());
            iTween.MoveUpdate(this.gameObject, hSettings);
            bLoopPositionSet = true;
            rReelParentObject.SyncronizePositionAllSlots();
        }
    }

}
