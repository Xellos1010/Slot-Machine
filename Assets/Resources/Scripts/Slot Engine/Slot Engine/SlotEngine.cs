//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : SlotEngine.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System;
using System.Collections;
using System.Collections.Generic;

public class SlotEngine : MonoBehaviour
{
    /// <summary>
    /// Player Information
    /// </summary>
	public PlayerInformation piPlayer ;

    //Static Self Reference
    private static SlotEngine instance;
    public static SlotEngine _instance
    {
        get
        {
            if (instance == null)
                instance = GameObject.FindGameObjectWithTag("Slot Engine").GetComponent<SlotEngine>();
            return instance;
        }
        set
        {
            instance = value;
        }
    }
    //*****************

    //Credit Racking Variables
	public float fCreditRackSpeed ;
	public int iRackCreditsRemaining ;
    //************

    //Engine Options
    public eSkins eSkin;
    public float fReelDividerWidth = 6;
    public Vector2 MatrixPadding = new Vector2(10,10);
    public Vector2 v2ReelTopLeft;
    public float reelSpinTime = 5;
    [Range(0, 50)]
    public float reelPaddingX = 40;
    [Range(0, 1)]
    public float fReelSpinDelay = .2f;

    public float fStartingSpotSlot = 50;
    [Range(0, 250)]
    public float slotPaddingY;

    /// <summary>
    /// Used to cushion the top and bottom of the reel
    /// </summary>
    [Range(2, 5)]
    public int iSlotCushionSpinning = 2;

    public MatrixTypes mMatrixType;
    public States CurrentMode = States.BaseGame;

    [Range(0, 100)]
    public float fStartStopSpeed = 50;
   /* [Range(0, 100)]
    public float fSpinSpeed = 50;*/

    [Range(1, 3)]
    public int iExtraSlotsPerReel = 2;

    //********

    //Slot Matrix
    protected internal Matrix mMainMatrix;

    //Matrix Evaluation
    public eEvaluationDirection ReelEvaluationDirection = eEvaluationDirection.Left;
    public int iPayLines = 99;
    //**********

    //Unity Functions
    void OnEnable()
    {
        StateManager.ActivateSwitchState += SwitchState; //Adds main state function to state machine
    }

    void Update()
    {
#if UNITY_ANDROID || UNITY_IPHONE
       if (Input.touchCount > 0)
        {
            Touch temp = Input.touches[0];
            if (temp.phase == TouchPhase.Ended)
            {
                Debug.Log("Test Generating Matrix");
                instance = this;
                CurrentMode = States.BaseGame;
                try
                {
                    Debug.Log("The Matrix has returned " + _MainMatrix);
                }
                catch
                {
                    Debug.Log("The Matrix has failed to create");

                }
            }
        }
#else
        /*
        if (Input.GetKeyDown(KeyCode.Space))
        {
            Debug.Log("Test Generating Matrix");
            instance = this;
            CurrentMode = States.BaseGame;
            try
            {
                mMainMatrix = CreateMatrix();
                Debug.Log("The Matrix has returned " + mMainMatrix);
            }
            catch
            {
                Debug.Log("The Matrix has failed to create");

            }
        }*/
#endif
    }
    //************************************

    //Default Functions
    void ZeroValues()
    {
        StateManager.ActivateSwitchState -= SwitchState;
        
    }
    public static object ReturnMatrixtype()
    {
        return ReturnMatrixtype(SlotEngine._instance.mMatrixType);
    }

    public static object ReturnMatrixtype(MatrixTypes mMatrix)
    {
        object ReturnValue = null;

        switch (mMatrix)
        {
            case MatrixTypes.m3x5:
                ReturnValue = new Vector2(3, 5);
                break;
            case MatrixTypes.m3x6:
                ReturnValue = new Vector2(3, 6);
                break;
            case MatrixTypes.m4x5:
                ReturnValue = new Vector2(4, 5);
                break;
            case MatrixTypes.m4x6:
                ReturnValue = new Vector2(4, 6);
                break;
            default:
                Debug.Log("Matrix is not able to set Vector2 to Define. Sending Matrix as an int[]");
                if (mMatrix == MatrixTypes.m3x4x5x4x3)
                    ReturnValue = new int[5] { 3, 4, 5, 4, 3 };
                break;
        }

        return ReturnValue;
    }

    public Matrix CreateMatrix() //Main matric Create Function
    {
        if (mMainMatrix == null)
        {
            Type[] MatrixComponents = new Type[1];
            MatrixComponents[0] = typeof(Matrix);
            mMainMatrix = new GameObject("MatrixObject", MatrixComponents).GetComponent<Matrix>();
            mMainMatrix.transform.tag = "MatrixParent";
            Debug.Log("Matrix was created now Setting Matrix");
        }
        mMainMatrix.GenerateMatrix(mMatrixType);
        return mMainMatrix;
    }
    //**************************

    //Engine Functions
	public void Spin()
    {
        StateManager.SwitchStateSpin(CurrentMode);
	}

	public void IncreaseCredits(int iAmount)
    {

	}

	public void CalculateCreditRackSpeed()
    {

	}

	public void CheckPlayerInformaiton()
    {

	}

    public void SwitchState(States State)
    {
        //Play State Transition Switching(State);
    }

    internal void UpdateReelSlotPositions()
    {
        Matrix matrixInUse = FindObjectOfType<Matrix>();
        for (int i = 0; i < matrixInUse.transform.childCount; i++)
        {
            matrixInUse.transform.GetChild(i).GetComponent<Reel>().UpdateSlotPositions();
        }
    }

    internal void UpdateReelPositions()
    {
        Matrix matrixInUse = FindObjectOfType<Matrix>();
        matrixInUse.UpdatePositionReels();
    }
    //******************
}

#if UNITY_EDITOR
[CustomEditor(typeof(SlotEngine))]
class SlotEngineEditor : Editor
{
    SlotEngine myTarget;
    SerializedProperty reelPaddingX;
    SerializedProperty slotPaddingY;

    public void OnEnable()
    {
        myTarget = (SlotEngine)target;
        reelPaddingX = serializedObject.FindProperty("reelPaddingX");
        slotPaddingY = serializedObject.FindProperty("slotPaddingY");
    }

    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        if (GUILayout.Button("Set Instance"))
        {
            SlotEngine._instance = myTarget;
        }
        if (GUILayout.Button("Generate Matrix"))
        {
            if (myTarget.mMainMatrix != null)
                DestroyImmediate(myTarget.mMainMatrix.gameObject);
            myTarget.mMainMatrix = myTarget.CreateMatrix();
        }

        EditorGUI.BeginChangeCheck();
        float newReelValue = EditorGUILayout.Slider(reelPaddingX.floatValue, 0, 250);
        float slotNewValue = EditorGUILayout.Slider(slotPaddingY.floatValue, 0, 250);
        if (EditorGUI.EndChangeCheck())
        {
            if (myTarget.slotPaddingY != slotNewValue)
            {
                myTarget.slotPaddingY = slotNewValue;
                myTarget.UpdateReelSlotPositions();
            }
            
            if(myTarget.reelPaddingX != newReelValue)
            {
                myTarget.reelPaddingX = newReelValue;
                myTarget.UpdateReelPositions();
            }
        }
    }
}
#endif