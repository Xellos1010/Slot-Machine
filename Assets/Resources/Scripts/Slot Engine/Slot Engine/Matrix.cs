//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Matrix.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System;
using System.Collections;
using System.Collections.Generic;

public class Matrix : MonoBehaviour
{
	private MatrixTypes enMatrixType = MatrixTypes.None;
	public int iWinningPayLines ;
    public int iSlotsPerReel = 0;
	public Reel[] rReels ;
	public List<Reel[]> rReelsMultiSpinConfiguration;
    protected List<Symbols[]> _ReelSymbols;
    private List<Symbols[]> ReelSymbols
    {
        get
        {
            if (_ReelSymbols == null)
                _ReelSymbols = GenerateEndReelsSymbols();
            if(_ReelSymbols.Count == 0)
                _ReelSymbols = GenerateEndReelsSymbols();
            return _ReelSymbols;
        }
        set
        {
            _ReelSymbols = value;
        }
    }
    //****Unity Default Functions

    void Update()
    {
#if UNITY_ANDROID || UNITY_IPHONE
        if(Input.touchCount > 0)
         {
             Touch temp = Input.touches[0];
             if (temp.phase == TouchPhase.Ended)
             {
                 if (StateManager.enCurrentState != States.BaseGameSpinLoop && StateManager.enCurrentState != States.BaseGameSpinStart)
                     StartCoroutine(SpinReelsTest());
                 else if (StateManager.enCurrentState == States.BaseGameSpinLoop)
                 {
                     //Put ending sequence coroutine here
                     Debug.Log("Ending Spin State");
                     StartCoroutine(SpinEnd());
                 }
             }
        }
#else
        if (Input.GetKeyDown(KeyCode.Space))
        {
            if (StateManager.enCurrentState != States.BaseGameSpinLoop && StateManager.enCurrentState != States.BaseGameSpinStart)
                StartCoroutine(SpinReelsTest());
            else if(StateManager.enCurrentState == States.BaseGameSpinLoop)
            {
                //Put ending sequence coroutine here
                Debug.Log("Ending Spin State");
                StartCoroutine(SpinEnd());
            }
        }
#endif
    }

    //***********

    public void SpinTest()
    {
        if (StateManager.enCurrentState != States.BaseGameSpinLoop && StateManager.enCurrentState != States.BaseGameSpinStart)
            StartCoroutine(SpinReelsTest());
        else if (StateManager.enCurrentState == States.BaseGameSpinLoop)
        {
            //Put ending sequence coroutine here
            Debug.Log("Ending Spin State");
            StartCoroutine(SpinEnd());
        }
    }

    IEnumerator SpinReelsTest()
    {
        //if(StateManager.state
        StateManager.SwitchState(States.BaseGameSpinStart);
        foreach (Reel rReel in rReels)
        {
            rReel.SpinReel();
            yield return new WaitForSeconds(SlotEngine._instance.fReelSpinDelay);
        }
        StateManager.SwitchState(States.BaseGameSpinLoop);
        for (int i = 0; i < rReels.Length; i++)
        {
            rReels[i].SetSlotEndConfiguration(GenerateEndReelSymbols());
        }
    }
    
    IEnumerator SpinEnd()
    {
        StateManager.SwitchState(States.BaseGameSpinEnd);
        Debug.Log("ReelSymbols.Count = " + ReelSymbols.Count);
        for (int i = 0; i < rReels.Length; i++)
        {
            rReels[i].StopReel();//Only use for specific reel Sotp features
        }
        yield return 0;
    }

	public void GenerateMatrix(MatrixTypes MatrixType)
    {
        enMatrixType = MatrixType;
        Debug.Log("Matrix Set to " +MatrixType + " Setting Reels");
        GenerateMatrix();
	}

	public void GenerateMatrix()
    {
        Debug.Log("Matrix.cs enMatrixType int = " + (int)enMatrixType + " enMatrixType = " + enMatrixType + " rReelsLength = ");
        //Setting the Type of matrix ex:3x5 4x5 3x4x5x4x3
        object Matrix = SlotEngine.ReturnMatrixtype();
        Vector2 v2Matrixtemp = new Vector2();
        int[] iMatrixtemp = new int[0];
            if(Matrix.GetType() == typeof(Vector2))
            {
                v2Matrixtemp = (Vector2)Matrix;
                rReels = new Reel[(int)v2Matrixtemp.y];
                //rReels = new Reel[1];
            }
            else if (Matrix.GetType() == typeof(int[]))
            {
                iMatrixtemp = (int[])Matrix;
                //rReels = new Reel[1];
                rReels = new Reel[iMatrixtemp.Length];
            }

        Debug.Log("Generating new reels");
        for (int i = 0; i < rReels.Length; i++)
        {
            rReels[i] = GenerateReel(i);
            //**Need to have Slots Set reference Matrix Type
            if(Matrix.GetType() == typeof(Vector2))
            {
                //Add 2 or more for padding purposes SlotEngine._instance.iExtraSlotsPerReel
                rReels[i].GenerateSlots((int)v2Matrixtemp.x+SlotEngine._instance.iExtraSlotsPerReel, rReels[i].transform);
                if (iSlotsPerReel == 0)
                    iSlotsPerReel = (int)v2Matrixtemp.x + SlotEngine._instance.iExtraSlotsPerReel;
            }
            else if (Matrix.GetType() == typeof(int[]))
            {
                //Add 2 or more for padding purposes SlotEngine._instance.iExtraSlotsPerReel
                rReels[i].GenerateSlots(iMatrixtemp[i] + (SlotEngine._instance.iExtraSlotsPerReel), rReels[i].transform);
                if (iSlotsPerReel == 0)
                    iSlotsPerReel = iMatrixtemp[i] + (SlotEngine._instance.iExtraSlotsPerReel);
            }
            //rReels[i].transform.position = GeneratePosition(i);
        }
	}

    Reel GenerateReel(int ReelNumber)
    {
        //Create Reel Game Object
        Type[] ReelType = new Type[1];
        ReelType[0] = typeof(Reel);
        //Debug.Log("Creating Reel Number " + ReelNumber);
        Reel ReturnValue = new GameObject("Reel_" + ReelNumber, ReelType).GetComponent<Reel>();
        //Debug.Log("Setting Transform and Parent Reel-" + ReelNumber);
        //Position object in Game Space based on Reel Number Then set the parent
        ReturnValue.transform.parent = transform;

        return ReturnValue;
    }

    Vector3 GeneratePosition(int iReelNumber)
    {

        float XAxisValue = (SlotEngine._instance.v2ReelTopLeft.x) + (SlotEngine._instance.fReelPadding * iReelNumber);

        //Need to have the Y axis Value set when the slots are assigned to the Reel Area.
        float YAxisValue = 0;//SlotEngine._instance.fStartingSpotReelY;
        Vector3 ReturnValue = new Vector3(XAxisValue,YAxisValue,0);
        //Need to calculate height and width of the symbols in the reel and pad according to padding set in place in master slot engine
        return ReturnValue;
    }

    List<Symbols[]> GenerateEndReelsSymbols()
    {
        List<Symbols[]> ReturnValue= new List<Symbols[]>(rReels.Length);
        for (int i = 0; i < ReturnValue.Count; i++)
        {
            ReturnValue[i] = new Symbols[rReels[i].transform.childCount];
            Symbols[] temp = ReturnValue[i];
            for (int j = 0; j < ReturnValue[i].Length; j++)
            {
                temp[j] = (Symbols)UnityEngine.Random.RandomRange(1, (int)Symbols.End);
            }
            ReturnValue[i] = temp;
        }
        return ReturnValue;
    }

    Symbols[] GenerateEndReelSymbols()
    {
        Symbols[] ReturnValue = new Symbols[iSlotsPerReel];
        for (int i = 0; i < ReturnValue.Length; i++)
        {
            ReturnValue[i] = (Symbols)UnityEngine.Random.RandomRange(1, (int)Symbols.End);
        }
        return ReturnValue;
    }

	public void SetMatrixCurrentSpin(Reel[] rReelConfiguration)
    {

	}

	public void SetMatrixNumberOfSpins(List<Reel[]> rReelConfiguration)
    {

	}

	public void PopMultiSpinConfiguration()
    {

	}
    /// <summary>
    /// This will animate the Payline. (May need to cache slots into Event and fire event off. Find out in Optimization Phase)
    /// </summary>
    /// <param name="iPayline"> Defines the Payline. Length of input should be reel length</param>
    public void AnimatePayLine(int[] iPayline)
    {
        for (int i = 0; i < iPayline.Length; i++)
        {
            rReels[i].slSlots[iPayline[i]].PlayAnimation();
        }
    }

}

#if UNITY_EDITOR
[CustomEditor(typeof(Matrix))]
class MatrixEditor : Editor
{
    Matrix myTarget;

    public void OnEnable()
    {
        myTarget = (Matrix)target;
    }

    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        if (Application.isPlaying)
        {
            if (StateManager.enCurrentState != States.BaseGameSpinLoop && StateManager.enCurrentState != States.BaseGameSpinStart)
                if (GUILayout.Button("Test Spin"))
                {
                    myTarget.SpinTest();
                }
                else if (StateManager.enCurrentState == States.BaseGameSpinLoop)
                {
                    if (GUILayout.Button("End Test Spin"))
                    {
                        myTarget.SpinTest();
                    }
                }    
        }
    }
}
#endif